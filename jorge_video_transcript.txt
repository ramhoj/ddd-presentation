0:00
Hello everyone. So last week I published this uh video talking about how we
0:07
architect Rails applications using Fizzy as an as an example and I got um several
0:13
questions about Fizzy codebase uh both before and after the video was released.
0:19
So today I would like to address some of those questions. I think some questions
0:24
uh would make for dedicated videos in the future but I selected a few that I
0:29
think I can I can go through um today and at the end of the video I've seen
0:34
that there is an area of interest which is uh the view layer in rails. So I'm going to share our philosophy and
0:41
approach um for views in our applications. So um let's go.
0:49
So uh the first question here by Matt is asking about the has one goldness um
0:55
association and and related model and um why are not using like a flag instead of
1:02
an additional record for representing that cards are uh can be uh golden why
1:08
aren't we using an an additional a boolean column I I guess so if we go to
1:13
the card model and we go to the golden concern we can find that association
1:20
which is indeed using a dedicated uh additional model which is an so there is
1:26
like another table that we are joining against uh for filtering golden cards or
1:33
for uh detecting uh whether a car is is golden or not. So um why we do this? So
1:41
there are several reasons well first of all if we used a boolean column for this it will be totally fine. This is not
1:47
like oh my god it will be terrible but I'm going to share the reasons. One thing is uh consistency.
1:54
So uh for example uh a card can be um
2:01
uh closable. So you can close a card. So for representing that a card is closable
2:08
we have this has one closure association which is using this additional closure
2:14
record. Uh in this case we went with that because when you use an additional
2:20
record uh you get like a date for free. So for representing when a card is
2:28
closed at uh which is here. So we can check what is the created at time stamp
2:34
in the record. So we get that for free. Um at some point we removed that but in
2:40
VC you could set reasons when closing cards. So you could say, "Oh, I'm closing this one as a duplicate." Uh,
2:47
and that was um stored in the in the card and we were storing that at this
2:54
model, a disclosure model. So in that regards, you could you can extend like the the quality of enclosed with
3:01
additional information. So a model or a table uh makes for a natural fit to do
3:07
that. Uh so um now with golden cards we are not
3:14
doing that. We are not quing the date. We are not quing the uh we don't have
3:20
additional information there but it's it's kind of consistent with how we are modeling data card can can be closed. So
3:27
in that regards I think it's it's it's better or slightly better for consistency. We are using the we are
3:33
doing the same for uh for example a card is postponable. So we have the not now
3:39
association um or the not now um
3:44
additional record to model that. So we keep things consistent. Another I think good reason is that is
3:52
filtering. So in fizzy you can combine filters and or you can filter cards by
3:58
multiple conditions and you can sort card cards on multiple conditions. If we
4:03
represented everything with um with columns at the card level um it will be
4:10
I mean we will have to be very mindful about um indexes like composite indexes.
4:17
So we will be need to make sure that we have the right indexes in place covering
4:22
all the columns in the right order that we can that someone can use when filtering for multiple conditions which
4:29
is kind of a a hassle uh to do. Uh this is simpler because by joining uh on
4:35
additional tables we get efficient filters just by having the right foreign
4:40
key uh indexes in place and we can combine those uh more easily right
4:46
without the the column ordering in the index being being a concern. So that's a another good reason I think.
4:54
Okay. Uh Rey is asking about uh are the rules for fixtures um when to add
5:01
fixtures or when to create objects. I would say Ry that uh the general idea we
5:07
try to follow is we try to avoid creating new records in fixtures. um
5:14
instead we try to build uh a realistic
5:19
um set of pictures and by realistic I mean it represents um data that makes
5:25
sense if you were using the application as a user. So we don't have things like
5:31
card one, card two, card three or closed card uh I don't know archived card. We
5:37
try to use names that represent um cards that a human will create. So that we
5:43
actually we the fixture system is part of our seeding system. So you can play with the
5:50
fixtures where you're using the app locally in development. So they they need to to make sense or we try them to
5:56
make sense and they should be like comprehensive enough to cover the most typical cases. So in general try having
6:02
to create records is something we try to avoid. We sometimes do for sure. Uh but
6:08
we try to avoid that as much as possible and the reason is the speed like fixtures are much uh faster than
6:15
creative creating ad hoc records because they um uh you can dump like the fixture
6:24
data set very quickly when the the test suite starts and then um you can roll
6:30
back the changes uh whenever each test runs. So that that approach is incredibly fast. Uh
6:38
uh if you created records uh when you create records at OG on every test uh
6:45
those insertions are slow are much slower than the initial dump that we do with with with fixtures. So
6:52
okay so Alex is asking about restful roots um how to design them and such. I
6:59
think this will be um this will be like the subject of a whole episode but we
7:05
are indeed um we lean towards creating restful roots like almost all the times.
7:12
Restful roots there are many benefits they play great with how HTTP work and
7:18
um a wonderful side effect or or consequence of using them is that you end up with uh small controllers that
7:24
are highly cohesive like doing one single thing. Uh and that comes by
7:30
design, right? Because you are you are um trying trying to represent like your
7:36
the resources that your application exposes exposed as um as uh nouns you
7:45
can act on using four verbs. So by by definition uh controllers remain very
7:51
small and very focused. And I think this kind of links with um what I talked in
7:58
in the last video talking about Rails architectures about how we don't use service objects we because our
8:03
controllers are already doing the same high level orchestration
8:09
uh role that service objects should should play and that they remain very
8:14
thin and very cohesive um in the way we use them. So um the question is about uh
8:21
that some models um like the comment doesn't nest inside a card but all the
8:27
comments nest inside like engagement. By the way this comment about engagement
8:33
made me realize that we are not using this engagement models or controllers anymore. That was part of uh previous
8:41
workflow we were supporting in Fizzy. So I just created a pull request to remove engagements because they were not used.
8:47
Uh but uh yeah regarding the question what this person is asking is um
8:55
um so for example if we go well this is a good example like uh for example for
9:00
postponing a card we associate this not model to them and this is in the name
9:06
space uh card not know right? If we go to the to this model uh this is nested
9:14
inside a card while other com other model like comment they are like root models right uh I don't think this is
9:23
sorry we are here I don't think this is um you know written in a stone or that
9:29
we follow very very hard rules here uh what what I think the re the the the
9:35
reasoning here is that a comment is is is kind of I I mean it depends on a card
9:40
to exist because you need a card for a comment to exist in fizzy but as an entity it um it is important enough on
9:49
its own. So for example a comment can generate events and you can get those events in the timeline and you can reach
9:56
a comment that way or um they generate activity that we send in emails. uh
10:02
comments are like they have like a substance outside of what a card is.
10:09
However, there are other models like is like engageable was back in the day but like uh uh this not now model or
10:17
goldness uh the goldness model we used to flag a card like golden like if we
10:25
removed the card prefix and name space you would say what is this goldness doing? uh is this is this something you
10:31
can attach to any model? Is this something that can that has entity outside of the card that acts act acts
10:39
as the host and the answer is no. So that's the reasoning we try to follow
10:44
but I don't know in general I think this a kind of subjective territory and maybe
10:49
different parameters have different uh views here those are my thoughts at least. Um
10:57
so Nick is asking about integrating Ruby LLM into Fizzy and yes uh so during the
11:05
development of Fizzy we explored um implementing certain AI features and we
11:11
used the Ruby LLM uh gem to do that. Uh the gem was fantastic. Uh by the way uh
11:16
it worked very very smoothly in all our explorations. Um we eventually didn't we
11:24
eventually dropped all the features we had built that were highly exploratory.
11:30
Um fizzy back in the day it had u a command bar that you could enter
11:35
commands with a certain syntax. We built that. Then we thought of introducing an
11:41
LLM powered liar on top of that so that you could use natural language to say things like close this card or assign
11:48
this card to I don't know Kevin or whatever. Uh we built we built that and
11:54
that was working pretty well. Um but uh there were it was falling short
12:00
in some other scenarios because as soon as you as soon as you have that in place um it's natural that you want to start
12:06
asking for things more uh fancier or more sophisticated uh and it wasn't covering like um it
12:14
wasn't working as well as we wanted it to work. Then um Stano explored um
12:21
another feature which was fizzy ask where um you would have like a chat with
12:26
a with a you know like if it was chaty inside fizzy where you could ask and interact with the system that way we we
12:34
used a rublm feature called tools to do that again it was working well but um it
12:42
wasn't as it wasn't working well in all the scenarios sometimes it would uh
12:48
provide like uh answers that were kind of poor or would um you wouldn't get
12:54
like the quality you would expect uh or the quality we want to set uh for our
13:01
products. So we dropped that feature too. We had su summaries we explored um
13:08
building weekly summaries of the activity that you've done. uh again it was working well in many cases in some
13:15
of the cases the summaries were a little bit meh so um we dropped that too so we
13:21
explored quite quite a few AI avenues but eventually we decided to launch
13:27
without them because we they were not good enough we learned some good lessons
13:33
and uh I know that there are like a lot of interest in in a company making AI
13:39
work uh at the level we want it to work. So, um there will be more news here in
13:46
the future, but uh that's the story of phys and AI.
13:52
Um yeah, now I have a series of questions asking about multi-tenency
13:59
uh and why did you decide not to go with SQLite? So actually Fizzy while we were
14:05
using it internally uh it was running on SQLite with a multi-tenency setup uh in
14:11
place. This was always like um a thing that uh we were exploring um or that was kind of
14:18
exploratory in nature. So the idea was like we're going to make multi-tenency work with SQLite. if by the end of the
14:25
project we haven't managed to to do that uh to to to make a to make it work as
14:31
well as we want to we are going to switch to to my SQL. So that was kind of the the idea here. Um
14:38
uh this was uh mostly the work of uh Kevin McConnell and and Mike Delesio. So
14:44
they I think they did a terrific work in terms of the difficulties they faced and
14:50
the sophistication of what they built. It was working well. Uh the problem was that at the end of the project where we
14:57
wanted to ship um there were some operational concerns regarding
15:02
how uh were we going to offer like the level of availability we want for our applications. Um so we run our
15:09
applications on multiple uh data centers. Uh we can uh so if one data
15:16
center fails we can fail over uh over the other data center. Um the databases
15:23
are replicated so that you can you know we can still provide the service um as
15:29
expected without interruptions or without major interruptions and and we have other a bunch of other uh efforts
15:36
in place to to ensure that we can offer you know very high availability
15:41
and um doing that with SQLite uh was presenting some operational
15:47
challenges that we were uncertain about. We didn't want to delay the launch uh
15:52
beyond uh what you know the date we had set and eventually we decide to go with
15:59
my SQL which is known territory for for the company. Um well that's that's the the story. Um
16:09
Marcel is asking about why not use a turbo frame with lazy loading as a pagination trigger since it's already
16:15
got an appearance observer. So um I mean the reason if you if you do
16:21
pagionation with turbo frames uh directly without anything else uh one problem you have is that you will have
16:28
uh turbo frames nested inside turbo frames inside turbo frames. So that's not going to to fly. Uh so we have a
16:35
system in place that involves an stimulus controller called uh pagenation
16:40
uh stimulus controller uh sorry pagination controller uh that kind of
16:47
uh take the frame that is going to trigger and you know move move it at the
16:52
top of the page so that you get like a sequence of turbo frames uh containing
16:57
the the pages and these turbo frames are they refresh with morph so that if you
17:03
pagionate for example in the in the activity timeline and then the page
17:08
refreshes because some event arrives you get like the the data smoothly updated
17:14
the pageinated data smoothly updated uh that way. Um
17:22
so that's what we are doing there for pagination. Uh by the way this as you
17:28
know F is open source so you can check all this AI stuff you can uh dive into
17:34
the pull requests uh you can check this pagionation code everything is in gith
17:39
uh basecam uh fizzy if you want to check it.
17:44
Uh finally well here I had two questions regarding the the view layer. One is
17:50
from Miguel which is asking that you include view logic and even HTML
17:55
snippets on your models. Is that the approach you usually follow? Uh it's not
18:01
like uh I think I know which parts you're referring to and I'm going to to review that next but in general that's
18:08
not what we do but I'm going to to elaborate on that uh next. And uh Jordan
18:14
was asking about the usage of template helpers. Uh why a component system is not needed. Uh
18:22
well and he's asking about delegate types and you know uh delegate types
18:27
there is something very exciting to bring light on delegate types that is in
18:32
the oven right now. So um I think you you will get some good information there
18:38
soon but I'm going to focus on the view on the view layer. Okay. So um
18:44
regarding views there've been like a I've seen some discussions recently
18:50
um talking about you know radius is missing like uh something like view
18:55
components because uh view helpers uh kind of fall short in some scenarios and
19:03
um erb templates are not enough. I'm going to share like how we do it and our philosophy and and some further thoughts
19:10
there. Okay. So, so I want to show you how we render this
19:15
view which is the activity timeline view because it's a view that is interesting.
19:20
It serves to show like different scenarios or how we deal with complexity when we are rendering views.
19:28
So if we go to um first to this day timeline scoped concern, we see that um
19:36
this is setting this this is invoking this set day timeline uh method that is uh setting this date timeline object
19:44
which is a plain Ruby object as the the main uh domain entity that the the
19:50
controller is setting so that the view can render it. So uh if I go now to the
19:55
controller, I'm going to go to the view because this view is show showing se several things. Um so show showing how
20:03
we deal with views pretty well. So first of all um we use um partials uh a lot.
20:13
So we try to divide our views into uh smaller chunks uh with proper names to
20:20
keep things organized just like you try to divide your long methods into uh
20:26
smaller methods uh the same level of abstraction to to make sense of the code or to make it easy to read. I think the
20:32
same pattern is uh totally something you can apply to to views. So we try to we
20:38
use partials to you know to extract uh and to make code
20:44
more readable. Uh we also use um helpers and view helpers in rail. So the
20:51
question is when do you use partial and a partial and when do you use a helper? So in this case for example if we go to
20:57
the uh uh sorry here if we go to the dame
21:03
timeline pagination frame tag uh this is a helper method this is rendering a
21:08
turbo frame um with some stimulus controller and some uh ID conventions
21:14
that's a very simple u that's a method that is returning a very simple HTML bit in that case uh helper works great in
21:24
other cases such as for example add card button the HTML you are rendering is
21:29
more substantial. So in general when the HTML to render is more substantial and unless there is uh a compelling reason
21:36
not to uh I lean towards using u templates sorry partials because they
21:43
are they they play better with with composing HTML than than helpers in Rails. Um, and actually I think that
21:51
Rails could do something uh better there like we could have we could have like something tighter to generate HTML in in
21:59
helpers. I'm not saying there is not margin for improvement there. But there is this discussion about uh whether we
22:06
should use uh view components or we should use uh because because partials
22:13
and helpers like kind of fell short in fall sort in some occasions.
22:18
Uh my take on this is that in general partials and helpers work great for us.
22:24
Um I think we cover probably 95% of the
22:29
needs we have in our applications in the way we work. Um whenever people talk
22:36
about uh replacing this with something else, I think that what we would have to
22:41
see is something that is so much better is like night and day night and day
22:47
better than what we have now in order to to embrace it. Uh I think at least that that will be my my view. uh think that
22:56
you know in 377 signals in the way we work um designers designers of 37
23:01
signals they have a lot of agency and autonomy to to make progress. I uh you
23:07
can go to to the fishy repo at fizzy at bascanfishy and just try to s uh search
23:14
uh close. I actually can do that. Uh if if I go here and I search uh closed pull
23:22
request where the author the author is uh Jason Cinders which is one of the
23:28
designers the the other one is 222 pull requests. Uh if we go to and Smith which
23:36
is the other designer 2072 pull request. So designers like they get a lot of
23:42
things done uh because they um work autonomously
23:48
and um they are of course they are not normal designers they are incredibly talented um they are experts in HTML
23:56
they are expert in CSS they can do Ruby they can do Rails they can do JavaScript. So they are uh they are
24:03
folks with skills let's say but uh I think it's very important like this uh
24:08
to us the view layer this HTML templates are like the common ground where
24:14
designers can iterate over and we programmers step in and try to help to
24:20
organize things or to tidy up things but in general the common ground is this is
24:26
h this HTML erb templates. So um if we
24:31
embraced like a more programmatic view to build these rails uh sorry these
24:37
views uh I think that common ground will suffer. Okay, because it will be a more
24:43
familiar way of building uh UI UI bits maybe for a programmer or it could make
24:50
for cool things at the programming side but at the expense of losing you know the familiarity and uh the powerful
25:00
declarative nature of HTML that we all are familiar with. So uh well I agree
25:08
that probably there is things we could do on you know to make helpers more uh
25:13
view helpers or something that helps you generate HTML programmatically
25:18
you know more easily. I I don't discuss that that would be a benefit uh or that there there is some potential there for
25:25
for making things better. Uh I'm skeptical that
25:31
you know replacing this like this uh index car add card button with a view component that does this with a class in
25:38
the middle. I'm skeptical that that's that's a life-changing approach to build user interfaces and because it's not
25:45
like you know uh significantly better.
25:50
I don't find it like a very I don't find a very appealing case to embrace view
25:56
components or you know other uh systems of components for views in Rails to
26:03
embrace that as a general way of building views. To me that's not an appealing path uh with the current state
26:10
of of things. Um they normally say that um a benefit of view components is that
26:17
you can test them. We the thing is that we rarely test our views like we um we
26:24
test our views through integration tests uh in the so test testing rails controllers essentially but we rarely we
26:32
we focus on the expected uh outcome in terms of database modifications uh kind
26:37
of HTTP response very rarely we check like the views uh the content of the
26:43
views to make sure uh we are generating the the views we want to generate
26:48
Um the reason again is that building um
26:56
uh building the reason is that um
27:02
views are like uh we keep iterating on views. Designers keep iterating on views even after thing something is shipped
27:08
they keep coming back and changing things. Uh we don't want to put uh to
27:14
write tests that get in the middle of that. Okay. So and also another reason is that this is not like uh lacking that
27:22
level of testing is not a source of a recurring source of bugs for us. So in
27:27
our experience this works pretty well in the way we work uh you know with our approach. We are not missing view tests
27:35
or tests for view specific things uh isolated from controllers so that you
27:40
can build a comprehensive suite of tests for your views. That's not uh a need. we
27:46
have so kind of um that kind of uh uh
27:52
goes in the line of we are not missing uh view components or or similar technologies.
27:58
Um something I wanted to show you is that we do sometimes this is rare but we
28:04
sometimes find that helpers fell short for organizing like uh complex view
28:09
needs and this is actually this view is actually uh an example here. So uh let
28:16
me show you how we render a day. Uh if we go to events day to the events day
28:22
template um we go to this event day timeline columns you can see how what I
28:29
was referring about the compos method philosophy here. This is doing two things. We have two partials uh at the
28:36
same level of abstraction. This is easy to understand. It keeps things organized and it works very well for for us. So if
28:43
I go to the columns um template here, we can see how this is saying render this
28:49
column um partial and I'm passing this uh column day timeline added column day
28:57
timeline added column day timeline closed column. Okay, so here we can see how the the view is is asking the domain
29:05
entity for this column object that it can render. Okay, if we go to those
29:11
methods and we go to see how those methods are created. Uh we can see how
29:17
uh this is returning a column again a plain Ruby object that you can ask for things like give me
29:24
your title or give me give me um group the events by hour so that I can render
29:31
them. So if I go to the view we will see how these templates are interacting with
29:37
those column objects. So uh you can totally make the case that those column
29:43
object this this column object here this is acting like a presenter object right.
29:49
This is wrapping like a this is offering to the views um this is offering to the
29:54
view layer an API that is built to satisfy the view layer needs. So this is
30:00
like a kind of a presenter object like in the like with the service object case
30:05
that I talked about the other day. uh we don't use the presenter bit in the
30:12
name. So we don't call this a column presenter just like we don't use sign up service for for the signup thing. We
30:19
just these are just plain objects uh that we are using to make rendering our
30:25
views uh you know nicer and to to keep the code more maintainable.
30:31
Um if we go to again if we go to the to the
30:36
view you can we can see how this is kind of more or less easy to
30:42
follow and easy to understand which is the the whole goal and so it means it's it's easy to to maintain um with this
30:49
approach now I want to point out that doing this is rare like it's rare that we resort to
30:55
that we normally do this when we are using helpers uh we using helper helper
31:01
objects normally you start to find that you need to create helpers that invoke
31:06
other helpers and they are always passing the same data through. So sometimes that's a good signal that you
31:13
need that some missing abstraction is is is there right like you're missing some
31:19
abstraction there. So in this case actually if you go to the pull requests or to the commits to these views you
31:24
will find that was actually the case. We had a system of helper objects. It was kind of messy. At some point we said
31:31
this is super messy. We are going to extract these things or these additional abstractions. Um
31:41
um okay. So that's one example. Uh another example of this let me let me go
31:48
to this view when we are rendering. No it's not here. Um
31:56
this is this is the rendering the column. Um I want to show you when we
32:04
are render Oh yeah here here we are rendering the events specifically. Okay. So um
32:12
when we render for example an an event specifically I'm trying to
32:17
locate the code which is here. Okay. Um
32:24
yeah here here's the line. Okay so when when we are rendering an event here the
32:30
event the body of the event like you will handle this or you assigned Kevin
32:35
that that piece of text is rendered here. Okay. So here this is another
32:40
example where we can ask the event model description for this user because the
32:49
description you see changes depending on who you are and we are rendering and to
32:54
HTML view of that description. If we go here, we're going to find again that
33:00
this description for method which is at the event model is returning this description object and this description
33:07
object has two methods. One to render as HTML and another one to render as plain
33:13
text. Uh this is because for rendering web hooks we use this version and for
33:18
rendering the views we use this one. So again this is another case where we had
33:23
like a salad of helper methods. It was quite messy. At some point we said okay we are going to refactor this. We are
33:29
going to stack this description entity and these are presentation concerns and
33:36
this is served from a model. This is rare we it's not that we are always
33:41
doing this but in this case it plays I think it's it's a good design. is a great design because we say oh event
33:47
give me your description for this user and we render this as HTML just like you
33:53
can uh render the HTML or the plain version of an action text attribute
33:58
right this is kind of similar to that so um I think this for the rare I think
34:04
these two scenarios are the only two scenarios where we are doing this creating this sort of presenter object
34:12
um I think that Uh, in general templates
34:17
and helpers work great 90% of the of the times and you can always create and we
34:25
certainly do create these additional uh kind of helper objects or presenter objects or however you want to call them
34:32
these additional objects that you know perform a proper implementation of more
34:37
complex behaviors. Okay, so that's this is something we do but again if you check our views this is rare. Okay. Uh
34:44
we we are templates and and view helpers uh all the time. We use that all the
34:50
time. All right. Um so I think we are
34:56
going to Oh yeah. Uh there was a last question here which is uh testing. How
35:01
much is enough and of what kind? I think this is a great question by um Miguel.
35:08
Um I think there is a great quote by Kent Beck talking about tests um like
35:13
the gold of tests is uh giving you confidence about uh your system. So this
35:20
is important to to have in mind because sometimes uh you know additional traits
35:25
like uh the speed of the test suite or the the coverage or um other aspects uh
35:34
become like a goal themselves. a goal by by themselves and
35:40
you need to keep in mind that tests the tests are they are not free like they they take time to write and they take
35:48
time to maintain which is very very important. So uh I used to have a more naive and purist approach towards
35:56
testing when I uh started many years ago or when I started with with automatic
36:01
testing at least. These days I really value uh tests that test the real thing.
36:09
uh integrated tests that kind of um exercise like the full stack and that
36:16
you can execute uh as if you were observing the system as a black box that
36:22
you interact with and where you observe the outcomes. Okay. So, uh I don't love
36:28
uh tests that are based on stabbing the internals of the class the classes
36:34
unless that's necessary of course or because you you need to mock out to mock out some dependency or something like
36:39
that then it's justified but in general I like the I don't know model tests that
36:45
are testing uh you know that the the database is
36:50
get the data uh you expect if you have a system of objects I like testing the the
36:56
the entity that is orchestrating the system of objects to try to see if the outcome is is what I want to see. Um so
37:05
in general I don't think it's a good smell that if you have a that if when you are going to change the internals of
37:13
an object uh tests broke. Okay, that's kind of an smell that you're not doing things right. So tests that uh test the
37:21
real thing being mindful about uh what to test and what not to test because because tests aren't free and uh I think
37:29
it's hard to give very strict deadlines but if you check uh our test suite in in
37:37
FY um what you will find is is uh
37:43
controller tests which are integration tests exercising our endpoints and uh
37:49
trying to see if the outcomes is what we expect. Um
37:55
uh you're going to find like unit tests for for models that again trying to
38:00
follow this philosophy and that's pretty much what what uh we
38:06
are doing. We are we have like some smoke tests um very high level. We have
38:12
experimented with system tests quite a bit. uh eventually we don't think like the tradeoffs are worth it. I they bring
38:19
value. They they are valuable but they are also slow. They can be brittle. They are slow to write and to maintain and to
38:27
run. And eventually we said like we decided that they were not uh worth it.
38:34
Um a final note I wanted to um comment is that uh none of this I think nothing
38:41
in software is like hardcore rules you must follow all the time. Okay. I'm uh
38:48
sometimes with with general advice you sometime take the advice too far. I want to show you a very recent test of
38:54
something we uh of a pull request I actually merged today uh which is related to enforcing storage limits in
39:02
Fizzy for the Fizzy uh sorry for the SAS side of the equation for the SAS service
39:08
that we run on on Fizzy. The pull request is in GitHub and you can check it. Uh the thing is that when you are
39:16
going to create a card uh depending on of the storage you are using uh we want
39:21
to show a certain notice and depending on the card count uh you're on your card
39:27
count we want to show certain messages for example inviting you to upgrade if you are close to reach one of those
39:33
limits or directly preventing you from creating cards if you are out of limits
39:39
and the bureau was kind of involved in that regard and to gain confidence over
39:44
the system, I decided to write a test uh which is uh I think it's card creation
39:51
test. Yeah, here it is. So, uh this is a test that is doing two things I said I
39:57
don't like to do. One is using uh an stabbing certain certain internal not
40:04
not not internal but stubbing certain method uh that I could this is not a
40:10
column I could write uh easily. So I decided to go with a staff to simulate different storage uh situations because
40:17
with the system we use to track storage we are not storing that at the account level. There is a more involved uh
40:24
system under the hood and uh I decided to go with that uh to to simulate
40:31
different uh storage situations uh because it was the easier option at
40:36
hand. Uh another thing is that here in this view I'm indeed and this is the main the main purpose of the of these
40:42
tests I'm checking that the output in the I'm see I'm checking that I'm seeing
40:48
like the right message I expect to see in the output which is something we we rarely do but in this case that was what
40:55
I wanted because I wasn't I wasn't certain about like uh is this robust enough so it's an example of a test
41:02
where I'm doing two things that I I have pointed out that we rarely do so you
41:08
know there is no rules that you say that you need to fulfill all the time uh or
41:14
you know never do that never do this people tend to be very categoric and in
41:19
software I don't think that plays very very well um okay uh this is all again
41:26
uh the video took longer than I expected I hope you find it useful um I wish you all merry Christmas and thank you for
41:33
your time take